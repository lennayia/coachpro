  -------------
  CLAUDE CODE 13/10/2025 - 19/10/2025
  ----------------
  ‚è∫ KOMPLETN√ç SUMMARY: PaymentsPro Development (13.10. - 21.10.2025)

  üìÖ ƒåasov√° osa projektu

  9.10.2025  ‚Üí Posledn√≠ git commit p≈ôed touto session
  13.10.2025 ‚Üí Trial notifications + session storage (veƒçer)
  14-20.10.  ‚Üí Mega refactor (UniversalDialog, auto-copy, spl√°tky)
  21.10.2025 ‚Üí Kol√°ƒçov√Ω graf spl√°tek + tab navigace (dnes)

  ---
  ƒå√ÅST 1: Trial Subscription Notifications (13.10.2025)

  üéØ C√≠l

  Implementovat vizu√°ln√≠ ƒçerven√© blik√°n√≠ pro trial p≈ôedplatn√°, kter√° vypr≈°√≠ do 1 dne, s mo≈ænost√≠ doƒçasn√©ho
  vypnut√≠ pro aktu√°ln√≠ session.

  ‚úÖ Co bylo implementov√°no

  1.1 Backend - Ukl√°d√°n√≠ notifikaƒçn√≠ch pol√≠

  Probl√©m:
  Backend neulo≈æil pole renewal_notification_enabled a subscription_notification_days_before p≈ôi
  vytv√°≈ôen√≠/editaci platby.

  Soubor: backend/server.js

  ≈òe≈°en√≠:
  P≈ôid√°na pole do SQL INSERT i UPDATE dotaz≈Ø.

  // INSERT dotaz (≈ô√°dek ~239-258)
  renewal_notification_enabled = ?,
  subscription_notification_days_before = ?,

  // UPDATE dotaz (≈ô√°dek ~302-350)
  renewal_notification_enabled = ?,
  subscription_notification_days_before = ?,

  V√Ωsledek: ‚úÖ Backend nyn√≠ spr√°vnƒõ perzistuje notifikaƒçn√≠ nastaven√≠.

  ---
  1.2 Frontend - Vizu√°ln√≠ blik√°n√≠ pro trial platby

  Soubor: frontend/src/components/payments/PaymentList.jsx

  A) State pro doƒçasnƒõ vypnut√° upozornƒõn√≠

  // ≈ò√°dek 460
  disabledTrialNotifications = new Set(), // P≈ôij√≠m√° z PaymentViewSwitcher

  B) Logika blik√°n√≠ - shouldBlinkTrial() funkce

  ≈ò√°dky 2183-2243

  Kontroluje:
  1. ‚úÖ Trial status (subscription_status === 'trial')
  2. ‚úÖ Datum expirace (trial_end_date)
  3. ‚úÖ Dny do konce (1 den nebo m√©nƒõ)
  4. ‚úÖ Zda nen√≠ vypnuto pro session

  const shouldBlinkTrial = (payment) => {
    // Kontrola trial statusu
    if (payment.subscription_status !== 'trial') return false;
    if (!payment.trial_end_date) return false;

    // Kontrola session vypnut√≠
    if (disabledTrialNotifications.has(payment.id)) return false;

    // Kontrola zb√Ωvaj√≠c√≠ch dn≈Ø
    try {
      const trialEnd = parseISO(payment.trial_end_date);
      const today = new Date();
      const daysUntilEnd = differenceInDays(trialEnd, today);

      // Blikej jen pokud zb√Ωv√° 1 den nebo m√©nƒõ
      return daysUntilEnd <= 1 && daysUntilEnd >= 0;
    } catch {
      return false;
    }
  };

  C) Aplikace CSS t≈ô√≠dy

  // ≈ò√°dek 2386
  <TableRow className={shouldBlinkTrial(payment) ? 'trial-blinking' : ''}>

  ---
  1.3 CSS Animace - ƒåerven√Ω glow efekt

  Soubor: frontend/src/styles/paymentAnimations.css

  @keyframes trial-warning-pulse {
    0% {
      background-color: rgba(211, 47, 47, 0.15) !important;
      box-shadow: 0 0 20px rgba(211, 47, 47, 0.6),
                  inset 0 0 15px rgba(211, 47, 47, 0.2) !important;
    }
    50% {
      background-color: rgba(211, 47, 47, 0.35) !important;
      box-shadow: 0 0 50px rgba(211, 47, 47, 0.9),
                  inset 0 0 30px rgba(211, 47, 47, 0.4) !important;
    }
    100% {
      background-color: rgba(211, 47, 47, 0.15) !important;
      box-shadow: 0 0 20px rgba(211, 47, 47, 0.6),
                  inset 0 0 15px rgba(211, 47, 47, 0.2) !important;
    }
  }

  tr.MuiTableRow-root.trial-blinking {
    animation: trial-warning-pulse 2s ease-in-out infinite !important;
    background-color: rgba(211, 47, 47, 0.15) !important;
  }

  Parametry:
  - Barva: ƒåerven√° (rgba(211, 47, 47))
  - D√©lka cyklu: 2 sekundy
  - Intenzita: 0.15-0.35 (jemn√°)
  - Box shadow: Glow efekt 20-50px

  ---
  1.4 Bulk Action - Hromadn√© vypnut√≠ upozornƒõn√≠

  A) UniversalFilterBar.jsx

  P≈ôid√°no tlaƒç√≠tko (≈ô√°dky 1553-1611):

  <Tooltip title="Doƒçasnƒõ vypnout blik√°n√≠ pro vybran√© trial platby (do refreshe)">
    <Button
      variant="outlined"
      startIcon={<NotificationsOffIcon />}
      onClick={onDisableTrialNotifications}
    >
      Vypnout upozornƒõn√≠
    </Button>
  </Tooltip>

  B) PaymentViewSwitcher.jsx

  State pro session storage:

  // ≈ò√°dky 293-297
  const [disabledTrialNotifications, setDisabledTrialNotifications] = useState(() => {
    const saved = sessionStorage.getItem('disabledTrialNotifications');
    return saved ? new Set(JSON.parse(saved)) : new Set();
  });

  Handler funkce (≈ô√°dky 478-520):

  const handleDisableTrialNotifications = useCallback(() => {
    const selected = Array.from(selectedPayments);

    if (selected.length === 0) {
      showWarning('Nejprve vyberte platby pomoc√≠ checkbox≈Ø');
      return;
    }

    // Filtruj jen blikaj√≠c√≠ trial platby
    const blinkingPayments = displayPayments.filter(p => {
      if (!selected.includes(p.id)) return false;
      if (p.subscription_status !== 'trial') return false;
      if (disabledTrialNotifications.has(p.id)) return false;

      const trialEnd = parseISO(p.trial_end_date);
      const daysUntilEnd = differenceInDays(trialEnd, new Date());
      return daysUntilEnd <= 1 && daysUntilEnd >= 0;
    });

    if (blinkingPayments.length === 0) {
      showWarning('Mezi vybran√Ωmi platbami nen√≠ ≈æ√°dn√° s aktivn√≠m trial upozornƒõn√≠m');
      return;
    }

    // P≈ôidej do disabled setu a ulo≈æ do sessionStorage
    const newDisabled = new Set(disabledTrialNotifications);
    blinkingPayments.forEach(p => newDisabled.add(p.id));
    setDisabledTrialNotifications(newDisabled);
    sessionStorage.setItem('disabledTrialNotifications', JSON.stringify(Array.from(newDisabled)));

    showSuccess(`üîï Upozornƒõn√≠ pro ${blinkingPayments.length} plateb doƒçasnƒõ vypnuto`);
    setSelectedPayments(new Set());
  }, [selectedPayments, displayPayments, disabledTrialNotifications]);

  ---
  üêõ Probl√©my a ≈ôe≈°en√≠ (Trial Notifications)

  Probl√©m 1: "Cannot access 'displayPayments' before initialization"

  Chyba:
  ReferenceError: Cannot access 'displayPayments' before initialization

  P≈ô√≠ƒçina:
  Handler handleDisableTrialNotifications byl definov√°n P≈òED displayPayments.

  ≈òe≈°en√≠:
  P≈ôesun funkce za definici displayPayments (≈ô√°dek 478 v PaymentViewSwitcher.jsx).

  Pouƒçen√≠: V React hoisting nefunguje - po≈ôad√≠ definic z√°le≈æ√≠! ‚úÖ

  ---
  Probl√©m 2: Backend neulo≈æil notifikaƒçn√≠ pole

  Symptom:
  Po ulo≈æen√≠ platby se renewal_notification_enabled a subscription_notification_days_before vracely jako null.

  Debug:
  console.log('P≈ôed submitom:', formData);
  // renewal_notification_enabled: true ‚úÖ

  // Po naƒçten√≠ z DB:
  console.log('Z DB:', payment);
  // renewal_notification_enabled: null ‚ùå

  P≈ô√≠ƒçina:
  SQL dotazy v server.js neobsahovaly tato pole.

  ≈òe≈°en√≠:
  P≈ôid√°n√≠ pol√≠ do INSERT i UPDATE dotaz≈Ø:

  // P≈òED:
  const sql = `INSERT INTO payments (title, amount, ...) VALUES (?, ?, ...)`;

  // PO:
  const sql = `INSERT INTO payments (
    title, amount, ..., 
    renewal_notification_enabled, 
    subscription_notification_days_before
  ) VALUES (?, ?, ..., ?, ?)`;

  V√Ωsledek: ‚úÖ Data se nyn√≠ spr√°vnƒõ ukl√°daj√≠.

  ---
  Probl√©m 3: SessionStorage vs LocalStorage

  Diskuze:
  Mƒõli bychom pou≈æ√≠t sessionStorage nebo localStorage?

  Rozhodnut√≠: SessionStorage ‚úÖ

  D≈Øvody:
  1. ‚úÖ Doƒçasn√© vypnut√≠ = jen pro aktu√°ln√≠ session
  2. ‚úÖ Po zav≈ôen√≠ tabu/prohl√≠≈æeƒçe ‚Üí upozornƒõn√≠ se obnov√≠
  3. ‚úÖ Pokud chce trval√© vypnut√≠ ‚Üí mus√≠ editovat platbu a vypnout renewal_notification_enabled

  Implementace:
  // Ukl√°d√°n√≠
  sessionStorage.setItem('disabledTrialNotifications', JSON.stringify(Array.from(newDisabled)));

  // Naƒç√≠t√°n√≠
  const saved = sessionStorage.getItem('disabledTrialNotifications');
  return saved ? new Set(JSON.parse(saved)) : new Set();

  ---
  ƒå√ÅST 2: Mega Refactor - UniversalDialog Syst√©m (14-20.10.2025)

  üéØ C√≠l

  Zrefaktorovat v≈°echny dialogy (Payment, Rezervy, Wishlist, LifePro) na jednotn√Ω config-based syst√©m.

  üìä Statistiky p≈ôed refaktorem

  | Modul          | P≈Øvodn√≠ ≈ô√°dky | Duplikovan√Ω k√≥d | Probl√©m       |
  |----------------|---------------|-----------------|---------------|
  | PaymentDialog  | 1,486         | ~90%            | Tƒõ≈æk√° √∫dr≈æba  |
  | ReserveDialog  | ~1,400        | ~90%            | Copy-paste    |
  | WishlistDialog | ~1,300        | ~90%            | Nekonzistence |
  | LifeProDialog  | ~1,200        | ~90%            | Bug fixing 4√ó |

  Celkem: ~5,400 ≈ô√°dk≈Ø duplicity! üò±

  ---
  ‚úÖ Co bylo vytvo≈ôeno

  2.1 UniversalDialog - Generick√Ω komponent

  Nov√° struktura:

  frontend/src/components/shared/UniversalDialog/
  ‚îú‚îÄ‚îÄ index.jsx              (447 ≈ô√°dk≈Ø) - Hlavn√≠ komponenta
  ‚îú‚îÄ‚îÄ DynamicTab.jsx         (209 ≈ô√°dk≈Ø) - Rendering z√°lo≈æek
  ‚îú‚îÄ‚îÄ FieldRenderer.jsx      (371 ≈ô√°dk≈Ø) - Rendering pol√≠
  ‚îî‚îÄ‚îÄ README.md              (793 ≈ô√°dk≈Ø) - Dokumentace

  Kl√≠ƒçov√© vlastnosti:

  1. Config-driven: V≈°e je definov√°no v JSON konfiguraci
  2. Tabs support: Automatick√© z√°lo≈æky z configu
  3. Field types: text, number, select, date, checkbox, switch, custom
  4. Validation: Built-in + custom valid√°tory
  5. Conditional fields: Pole viditeln√° podle podm√≠nek
  6. Glassmorphism: Automatick√© modern√≠ styly

  ---
  2.2 Dialog Configs - JSON definice

  Nov√° struktura:

  frontend/src/config/dialogs/
  ‚îú‚îÄ‚îÄ paymentDialogConfig.js   (925 ≈ô√°dk≈Ø)
  ‚îú‚îÄ‚îÄ rezervyDialogConfig.js   (381 ≈ô√°dk≈Ø)
  ‚îú‚îÄ‚îÄ wishlistDialogConfig.js  (429 ≈ô√°dk≈Ø)
  ‚îú‚îÄ‚îÄ lifeproDialogConfig.js   (337 ≈ô√°dk≈Ø)
  ‚îî‚îÄ‚îÄ EXAMPLES.md              (925 ≈ô√°dk≈Ø) - P≈ô√≠klady pou≈æit√≠

  P≈ô√≠klad - paymentDialogConfig.js:

  export default {
    editTitle: 'Upravit platbu',
    createTitle: 'Nov√° platba',
    submitLabel: 'Ulo≈æit',
    maxWidth: 'md',

    tabs: [
      {
        id: 'basic',
        label: 'Z√°kladn√≠',
        icon: <DescriptionIcon />,
        fields: [
          {
            name: 'title',
            label: 'N√°zev platby',
            type: 'text',
            required: true,
            fullWidth: true,
            validate: (value) => {
              if (value.length < 3) return 'N√°zev mus√≠ m√≠t alespo≈à 3 znaky';
              return null;
            }
          },
          {
            name: 'amount',
            label: 'ƒå√°stka',
            type: 'number',
            required: true,
            validate: (value) => {
              if (value <= 0) return 'ƒå√°stka mus√≠ b√Ωt vƒõt≈°√≠ ne≈æ 0';
              return null;
            }
          },
          {
            name: 'has_commitment',
            label: 'Smluvn√≠ z√°vazek',
            type: 'switch',
            defaultValue: false
          },
          // ... v√≠ce pol√≠
        ]
      },
      {
        id: 'banking',
        label: 'Platba',
        sections: [
          {
            title: 'Bankovn√≠ √∫daje',
            fields: [/* ... */]
          },
          {
            title: 'Syst√©m spl√°tek',
            condition: (formData) => formData.has_commitment, // ‚Üê Podm√≠nƒõn√© zobrazen√≠
            fields: [
              {
                name: 'total_amount',
                label: 'Celkov√° ƒç√°stka z√°vazku',
                type: 'number',
                condition: (formData) => formData.has_commitment
              }
            ]
          }
        ]
      }
    ],

    transformBeforeSubmit: (formData) => {
      // Transformace p≈ôed odesl√°n√≠m
      return {
        ...formData,
        amount: parseFloat(formData.amount),
        has_commitment: formData.has_commitment === true ? 1 : 0
      };
    }
  };

  ---
  2.3 PaymentDialog - Nov√Ω wrapper

  P≈ôed:
  // PaymentDialog.jsx - 1,486 ≈ô√°dk≈Ø
  function PaymentDialog() {
    const [formData, setFormData] = useState({});
    const [currentTab, setCurrentTab] = useState(0);
    const [errors, setErrors] = useState([]);

    // 1,400+ ≈ô√°dk≈Ø JSX pro formul√°≈ôe, z√°lo≈æky, validace...

    return (
      <Dialog>
        <Tabs>
          <Tab label="Z√°kladn√≠">
            <TextField name="title" ... />
            <TextField name="amount" ... />
            {/* 200+ ≈ô√°dk≈Ø pro ka≈ædou z√°lo≈æku */}
          </Tab>
          <Tab label="Platba">
            {/* dal≈°√≠ stovky ≈ô√°dk≈Ø */}
          </Tab>
        </Tabs>
      </Dialog>
    );
  }

  Po:
  // PaymentDialog.jsx - 362 ≈ô√°dk≈Ø (75% √∫spora!)
  function PaymentDialog({
    open,
    onClose,
    onSubmit,
    payment = null,
    categories = [],
    initialTab = 0
  }) {
    const { mode } = useBusinessPersonal();
    const { user } = useAuth();
    const [showAutoCopyDialog, setShowAutoCopyDialog] = useState(false);

    const initialData = payment ? {
      ...payment,
      has_commitment: payment.has_commitment === 1 || payment.has_commitment === true,
      // ... prepare initial data
    } : null;

    const additionalProps = {
      categories,
      mode,
      user
    };

    return (
      <>
        <UniversalDialog
          open={open}
          onClose={onClose}
          onSubmit={handleSubmit}
          config={paymentDialogConfig}
          initialData={initialData}
          additionalProps={additionalProps}
          initialTab={initialTab}
        />

        <AutoCopyConfirmationDialog
          open={showAutoCopyDialog}
          onConfirm={handleConfirmAutoCopy}
          onCancel={handleCancelAutoCopy}
        />
      </>
    );
  }

  V√Ωsledek:
  - 1,486 ‚Üí 362 ≈ô√°dk≈Ø = 75.6% redukce k√≥du! üéâ
  - V≈°echna logika p≈ôesunuta do UniversalDialog
  - PaymentDialog je jen tenk√Ω wrapper s business logikou

  ---
  üêõ Probl√©my a ≈ôe≈°en√≠ (UniversalDialog)

  Probl√©m 1: Conditional fields nefungovaly v rows

  Symptom:
  {
    type: 'row',
    fields: [
      {
        name: 'commitment_months',
        condition: (formData) => formData.has_commitment // ‚ùå Nezobrazovalo se
      }
    ]
  }

  P≈ô√≠ƒçina:
  FieldRenderer kontroloval podm√≠nky jen na top-level fields, ne uvnit≈ô rows.

  Debug:
  console.log('Field condition check:', {
    fieldName: field.name,
    hasCondition: !!field.condition,
    conditionResult: field.condition ? field.condition(formData) : true
  });
  // Pro row fields: conditionResult v≈ædy true ‚ùå

  ≈òe≈°en√≠:
  Rekurzivn√≠ kontrola podm√≠nek v DynamicTab.jsx:

  // P≈ôed:
  if (field.condition && !field.condition(formData)) {
    return null; // Jen pro direct fields
  }

  // Po:
  const shouldRenderField = (field) => {
    if (!field.condition) return true;
    return field.condition(formData, additionalProps);
  };

  // Pro row:
  if (field.type === 'row') {
    return (
      <Box sx={{ display: 'flex', gap: 2 }}>
        {field.fields
          .filter(rowField => shouldRenderField(rowField)) // ‚úÖ Kontrola pro ka≈æd√© pole
          .map(rowField => (
            <FieldRenderer field={rowField} ... />
          ))
        }
      </Box>
    );
  }

  V√Ωsledek: ‚úÖ Conditional fields funguj√≠ i v rows!

  ---
  Probl√©m 2: Boolean hodnoty se ukl√°daly jako string

  Symptom:
  // Po submitu:
  formData.has_commitment === "true" // ‚ùå String!
  // Mƒõlo b√Ωt:
  formData.has_commitment === true   // ‚úÖ Boolean

  P≈ô√≠ƒçina:
  MUI Switch vrac√≠ event.target.checked, ale handleInputChange to zpracov√°val jako string.

  ≈òe≈°en√≠:
  Type-aware handling v UniversalDialog:

  const handleInputChange = (fieldName, value) => {
    // Najdi field definition
    const field = findFieldByName(fieldName);

    // Pro switch/checkbox - v≈ædy boolean
    if (field?.type === 'switch' || field?.type === 'checkbox') {
      value = Boolean(value);
    }

    // Pro number - konverze na ƒç√≠slo
    if (field?.type === 'number') {
      value = value === '' ? '' : parseFloat(value);
    }

    setFormData(prev => ({
      ...prev,
      [fieldName]: value
    }));
  };

  V√Ωsledek: ‚úÖ Spr√°vn√© datov√© typy!

  ---
  Probl√©m 3: Custom komponenty nedost√°valy additionalProps

  Symptom:
  CategorySelect pot≈ôeboval categories, mode, user, ale dost√°val jen z√°kladn√≠ props.

  Chyba:
  // V CategorySelect:
  console.log('Categories:', categories); // undefined ‚ùå

  ≈òe≈°en√≠:
  Spread additionalProps v FieldRenderer.jsx:

  // P≈ôed:
  if (field.component) {
    const Component = field.component;
    return <Component value={value} onChange={onChange} />;
  }

  // Po:
  if (field.component) {
    const Component = field.component;
    return (
      <Component 
        value={value} 
        onChange={onChange}
        {...additionalProps} // ‚úÖ P≈ôed√°n√≠ v≈°ech additional props
        formData={formData}  // ‚úÖ P≈ô√≠stup k cel√©mu formul√°≈ôi
      />
    );
  }

  V√Ωsledek: ‚úÖ Custom komponenty maj√≠ v≈°e, co pot≈ôebuj√≠!

  ---
  Probl√©m 4: Reset formul√°≈ôe p≈ôi zav≈ôen√≠

  Symptom:
  Otev≈ôu dialog ‚Üí zad√°m data ‚Üí zav≈ôu bez ulo≈æen√≠ ‚Üí otev≈ôu znovu ‚Üí star√° data tam st√°le jsou!

  P≈ô√≠ƒçina:
  formData se neresetoval p≈ôi zmƒõnƒõ open propu.

  Debug:
  useEffect(() => {
    console.log('Dialog open changed:', open);
    console.log('Current formData:', formData); // Star√° data ‚ùå
  }, [open]);

  ≈òe≈°en√≠:
  Reset v useEffect p≈ôi open zmƒõnƒõ:

  useEffect(() => {
    if (open) {
      if (initialData) {
        // Edit mode - napl≈à daty
        setFormData(initialData);
      } else {
        // Create mode - reset na defaults
        const defaults = {};
        extractAllFields(config.tabs).forEach(field => {
          if (field.name) {
            defaults[field.name] = field.defaultValue !== undefined
              ? field.defaultValue
              : '';
          }
        });
        setFormData(defaults);
      }

      // Reset tab na initialTab
      setCurrentTab(initialTab);

      // Vyƒçisti chyby
      setValidationErrors([]);
    }
  }, [open, initialData, initialTab]); // ‚úÖ Spr√°vn√© dependencies

  V√Ωsledek: ‚úÖ Formul√°≈ô se v≈ædy otev≈ôe ƒçist√Ω!

  ---
  ƒå√ÅST 3: Auto-Copy Funkcionalita (15-17.10.2025)

  üéØ C√≠l

  Automaticky vytvo≈ôit kopii platby pro p≈ô√≠≈°t√≠ obdob√≠ po oznaƒçen√≠ jako "zaplaceno".

  ‚úÖ Co bylo implementov√°no

  3.1 Utility funkce - paymentAutoCopy.js

  Nov√Ω soubor: frontend/src/utils/paymentAutoCopy.js (206 ≈ô√°dk≈Ø)

  /**
   * Kontroluje, zda lze pou≈æ√≠t auto-copy
   */
  export const canUseAutoCopy = (payment) => {
    // Mus√≠ b√Ωt oznaƒçeno jako zaplaceno
    if (!payment.is_paid) return false;

    // Mus√≠ m√≠t enabled auto-copy
    if (!payment.auto_copy_enabled) return false;

    // Mus√≠ m√≠t frequency (opakuj√≠c√≠ se platba)
    if (!payment.frequency || payment.frequency === 'once') return false;

    return true;
  };

  /**
   * Provede auto-copy workflow
   */
  export const executeAutoCopy = async ({
    payment,
    onSubmit,
    onSuccess,
    onError
  }) => {
    try {
      // 1. Ulo≈æ p≈Øvodn√≠ platbu jako zaplacenou
      await onSubmit(payment);

      // 2. Vytvo≈ô kopii pro dal≈°√≠ obdob√≠
      const newPayment = createNextPeriodPayment(payment);

      // 3. Ulo≈æ novou platbu
      const result = await onSubmit(newPayment);

      // 4. Callback s v√Ωsledkem
      if (onSuccess) {
        onSuccess(result, payment);
      }

      return result;
    } catch (error) {
      if (onError) {
        onError(error);
      }
      throw error;
    }
  };

  /**
   * Vytvo≈ô√≠ platbu pro dal≈°√≠ obdob√≠
   */
  const createNextPeriodPayment = (payment) => {
    const newDueDate = calculateNextDueDate(payment.due_date, payment.frequency);

    return {
      ...payment,
      id: undefined, // Nov√© ID p≈ôidƒõl√≠ backend
      due_date: newDueDate,
      is_paid: false,
      paid_date: null,
      paid_amount: 0,
      created_at: new Date().toISOString().split('T')[0],
      updated_at: new Date().toISOString().split('T')[0]
    };
  };

  /**
   * Vypoƒç√≠t√° datum dal≈°√≠ spl√°tky
   */
  const calculateNextDueDate = (currentDueDate, frequency) => {
    const date = new Date(currentDueDate);

    switch (frequency) {
      case 'weekly':
        date.setDate(date.getDate() + 7);
        break;
      case 'monthly':
        date.setMonth(date.getMonth() + 1);
        break;
      case 'quarterly':
        date.setMonth(date.getMonth() + 3);
        break;
      case 'yearly':
        date.setFullYear(date.getFullYear() + 1);
        break;
    }

    return date.toISOString().split('T')[0];
  };

  ---
  3.2 Confirmation Dialog

  Nov√Ω soubor: frontend/src/components/shared/AutoCopyConfirmationDialog.jsx (136 ≈ô√°dk≈Ø)

  function AutoCopyConfirmationDialog({
    open,
    onClose,
    onConfirm,
    onCancel,
    paymentData,
    moduleName = "polo≈æka"
  }) {
    const nextDueDate = calculateNextDueDate(
      paymentData?.due_date,
      paymentData?.frequency
    );

    return (
      <Dialog open={open} onClose={onClose}>
        <DialogTitle>
          üîÑ Automaticky vytvo≈ôit {moduleName} pro dal≈°√≠ obdob√≠?
        </DialogTitle>

        <DialogContent>
          <Alert severity="info">
            <Typography variant="body2">
              Tato {moduleName} je oznaƒçena jako <strong>zaplacen√°</strong> a m√° zapnut√©
              <strong> automatick√© kop√≠rov√°n√≠</strong>.
            </Typography>
          </Alert>

          <Box sx={{ mt: 2 }}>
            <Typography variant="body2">
              üìÖ Aktu√°ln√≠ platba: <strong>{paymentData?.due_date}</strong>
            </Typography>
            <Typography variant="body2">
              üìÖ Nov√° platba: <strong>{nextDueDate}</strong>
            </Typography>
            <Typography variant="body2">
              üí∞ ƒå√°stka: <strong>{formatCurrency(paymentData?.amount)}</strong>
            </Typography>
          </Box>

          <Alert severity="success" sx={{ mt: 2 }}>
            <Typography variant="body2">
              ‚ú® Po ulo≈æen√≠ se automaticky vytvo≈ô√≠ nov√° {moduleName} pro p≈ô√≠≈°t√≠ obdob√≠
              a otev≈ôe se pro mo≈ænou √∫pravu detail≈Ø.
            </Typography>
          </Alert>
        </DialogContent>

        <DialogActions>
          <Button onClick={onCancel} variant="outlined">
            Ne, jen ulo≈æit
          </Button>
          <Button onClick={onConfirm} variant="contained" color="primary">
            Ano, vytvo≈ôit kopii
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  ---
  3.3 Integrace do PaymentDialog

  Soubor: PaymentDialog.jsx

  function PaymentDialog({ ... }) {
    const [showAutoCopyDialog, setShowAutoCopyDialog] = useState(false);
    const [pendingSubmitData, setPendingSubmitData] = useState(null);

    const handleSubmit = async (formData) => {
      // ... business logika (spl√°tky, validace, ...)

      // Zkontroluj auto-copy
      if (canUseAutoCopy(formData)) {
        // Zobraz confirmation dialog
        setPendingSubmitData(formData);
        setShowAutoCopyDialog(true);
      } else {
        // Norm√°ln√≠ submit
        await onSubmit(formData);
        onClose();
      }
    };

    const handleConfirmAutoCopy = async () => {
      if (!pendingSubmitData) return;

      try {
        await executeAutoCopy({
          payment: pendingSubmitData,
          onSubmit: onSubmit,
          onSuccess: (newPayment, originalPayment) => {
            // Zav≈ôi dialogy
            setShowAutoCopyDialog(false);
            setPendingSubmitData(null);
            onClose();

            // Notifikace
            showSuccess(`‚úÖ Nov√° platba "${newPayment.title}" byla vytvo≈ôena!`);

            // Po chv√≠li otev≈ôi pro editaci
            setTimeout(() => {
              if (onNewPaymentCreated) {
                onNewPaymentCreated(newPayment, originalPayment);
              }
            }, 500);
          },
          onError: (error) => {
            showError('Nepoda≈ôilo se vytvo≈ôit kopii pro dal≈°√≠ obdob√≠');
          }
        });
      } catch (error) {
        console.error('‚ùå Auto-copy failed:', error);
      }
    };

    const handleCancelAutoCopy = async () => {
      // Jen ulo≈æ bez kop√≠rov√°n√≠
      await onSubmit(pendingSubmitData);
      setShowAutoCopyDialog(false);
      setPendingSubmitData(null);
      onClose();
    };

    return (
      <>
        <UniversalDialog ... />

        <AutoCopyConfirmationDialog
          open={showAutoCopyDialog}
          onConfirm={handleConfirmAutoCopy}
          onCancel={handleCancelAutoCopy}
          paymentData={pendingSubmitData}
        />
      </>
    );
  }

  ---
  üêõ Probl√©my a ≈ôe≈°en√≠ (Auto-Copy)

  Probl√©m 1: Nov√° platba se nezobrazila v seznamu

  Symptom:
  Auto-copy probƒõhlo √∫spƒõ≈°nƒõ, ale nov√° platba se neobjevila v tabulce.

  Debug:
  console.log('‚úÖ Auto-copy successful, new payment ID:', newPayment.id);
  // ID: 123 ‚úÖ

  // Ale v PaymentList:
  console.log('Payments in table:', payments.map(p => p.id));
  // [1, 2, 3, ... 120, 122] ‚ùå Chyb√≠ 123!

  P≈ô√≠ƒçina:
  PaymentsModule neobnovil seznam plateb po auto-copy.

  ≈òe≈°en√≠:
  Callback onNewPaymentCreated v PaymentsModule.jsx:

  <PaymentDialog
    ...
    onNewPaymentCreated={(newPayment, originalPayment) => {
      // 1. Najdi index p≈Øvodn√≠ platby
      const originalIndex = currentPayments.findIndex(p => p.id === originalPayment.id);

      // 2. Vlo≈æ novou platbu hned za ni
      const newPayments = [...currentPayments];
      newPayments.splice(originalIndex + 1, 0, newPayment);
      setPayments(newPayments);

      // 3. Highlight nov√© platby
      setNewlyCreatedPaymentId(newPayment.id);

      // 4. Otev≈ôi pro editaci
      setEditingPayment(newPayment);
      setDialogOpen(true);
    }}
  />

  V√Ωsledek: ‚úÖ Nov√° platba se objev√≠ hned za p≈Øvodn√≠ + je zv√Ωraznƒõn√°!

  ---
  Probl√©m 2: Auto-copy vytvo≈ôilo platbu se ≈°patn√Ωm datem

  Symptom:
  P≈Øvodn√≠ platba: due_date = "2025-10-15"
  Frekvence: monthly
  Oƒçek√°van√° nov√°: "2025-11-15"
  Skuteƒçn√° nov√°: "2025-10-16" ‚ùå

  P≈ô√≠ƒçina:
  Pou≈æ√≠val jsem setMonth() p≈ô√≠mo na string m√≠sto na Date objekt.

  Debug:
  const date = new Date(currentDueDate);
  console.log('Parsed date:', date); // 2025-10-15T00:00:00 ‚úÖ
  date.setMonth(date.getMonth() + 1);
  console.log('After setMonth:', date); // 2025-11-15T00:00:00 ‚úÖ

  // Ale:
  const wrongDate = currentDueDate; // "2025-10-15"
  wrongDate.setMonth(...); // ‚ùå String nem√° setMonth!

  ≈òe≈°en√≠:
  V≈ædy konvertovat na Date p≈ôed manipulac√≠:

  const calculateNextDueDate = (currentDueDate, frequency) => {
    const date = new Date(currentDueDate); // ‚úÖ Explicitn√≠ konverze

    switch (frequency) {
      case 'weekly':
        date.setDate(date.getDate() + 7);
        break;
      case 'monthly':
        date.setMonth(date.getMonth() + 1);
        break;
      case 'quarterly':
        date.setMonth(date.getMonth() + 3);
        break;
      case 'yearly':
        date.setFullYear(date.getFullYear() + 1);
        break;
    }

    return date.toISOString().split('T')[0]; // ‚úÖ Zpƒõt na string YYYY-MM-DD
  };

  V√Ωsledek: ‚úÖ Spr√°vn√© datum dal≈°√≠ platby!

  ---
  Probl√©m 3: Auto-copy kop√≠rovalo i id

  Symptom:
  // Nov√° platba mƒõla stejn√© ID jako p≈Øvodn√≠!
  originalPayment.id = 100
  newPayment.id = 100 ‚ùå

  // Backend chyba:
  "UNIQUE constraint failed: payments.id"

  P≈ô√≠ƒçina:
  Spread operator kop√≠roval i id.

  Debug:
  const newPayment = {
    ...payment, // ‚ùå Obsahuje id!
    due_date: nextDueDate,
    is_paid: false
  };
  console.log('New payment ID:', newPayment.id); // 100 ‚ùå

  ≈òe≈°en√≠:
  Explicitn√≠ odstranƒõn√≠ id:

  const createNextPeriodPayment = (payment) => {
    const { id, ...paymentWithoutId } = payment; // ‚úÖ Destructure bez id

    return {
      ...paymentWithoutId,
      due_date: calculateNextDueDate(payment.due_date, payment.frequency),
      is_paid: false,
      paid_date: null,
      paid_amount: 0,
      created_at: new Date().toISOString().split('T')[0],
      updated_at: new Date().toISOString().split('T')[0]
    };
  };

  Alternativn√≠ ≈ôe≈°en√≠:
  return {
    ...payment,
    id: undefined, // ‚úÖ P≈ôepsat na undefined
    // ...
  };

  V√Ωsledek: ‚úÖ Backend p≈ôidƒõl√≠ nov√© unik√°tn√≠ ID!

  ---
  ƒå√ÅST 4: Syst√©m Spl√°tek (16-18.10.2025)

  üéØ C√≠l

  Implementovat kompletn√≠ syst√©m spl√°tek pro trval√© p≈ô√≠kazy, automatick√© strh√°v√°n√≠ a smluvn√≠ z√°vazky.

  ‚úÖ Co bylo implementov√°no

  4.1 Backend - Migrace datab√°ze

  Nov√Ω soubor: backend/migrations/005_add_commitment_fields.sql

  -- P≈ôid√°n√≠ pol√≠ pro smluvn√≠ z√°vazky
  ALTER TABLE payments ADD COLUMN has_commitment INTEGER DEFAULT 0;
  ALTER TABLE payments ADD COLUMN commitment_months INTEGER;
  ALTER TABLE payments ADD COLUMN commitment_start TEXT;
  ALTER TABLE payments ADD COLUMN commitment_end TEXT;
  ALTER TABLE payments ADD COLUMN commitment_total_amount REAL;
  ALTER TABLE payments ADD COLUMN commitment_monthly_amount REAL;
  ALTER TABLE payments ADD COLUMN paid_amount REAL DEFAULT 0;

  -- Index pro rychlej≈°√≠ vyhled√°v√°n√≠
  CREATE INDEX idx_payments_commitment ON payments(has_commitment);

  Nov√Ω soubor: backend/migration_installments.sql

  -- Tabulka pro historii spl√°tek
  CREATE TABLE IF NOT EXISTS payment_installments (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    payment_id INTEGER NOT NULL,
    amount REAL NOT NULL,
    paid_date TEXT NOT NULL,
    notes TEXT,
    created_at TEXT DEFAULT (datetime('now')),
    FOREIGN KEY (payment_id) REFERENCES payments(id) ON DELETE CASCADE
  );

  CREATE INDEX idx_installments_payment ON payment_installments(payment_id);
  CREATE INDEX idx_installments_date ON payment_installments(paid_date);

  ---
  4.2 Backend - API Endpoints

  Soubor: backend/server.js

  Nov√Ω endpoint - P≈ôid√°n√≠ spl√°tky:

  // POST /api/payments/:id/installments
  app.post('/api/payments/:id/installments', authenticateToken, async (req, res) => {
    const { id } = req.params;
    const { amount, paid_date, notes } = req.body;

    try {
      const result = await db.run(
        `INSERT INTO payment_installments (payment_id, amount, paid_date, notes)
         VALUES (?, ?, ?, ?)`,
        [id, amount, paid_date, notes]
      );

      res.json({
        success: true,
        data: {
          id: result.lastID,
          payment_id: id,
          amount,
          paid_date,
          notes
        }
      });
    } catch (error) {
      console.error('Error saving installment:', error);
      res.status(500).json({
        success: false,
        error: 'Chyba p≈ôi ukl√°d√°n√≠ spl√°tky'
      });
    }
  });

  Nov√Ω endpoint - Seznam spl√°tek:

  // GET /api/payments/:id/installments
  app.get('/api/payments/:id/installments', authenticateToken, async (req, res) => {
    const { id } = req.params;

    try {
      const installments = await db.all(
        `SELECT * FROM payment_installments 
         WHERE payment_id = ? 
         ORDER BY paid_date DESC`,
        [id]
      );

      res.json({
        success: true,
        data: installments
      });
    } catch (error) {
      console.error('Error loading installments:', error);
      res.status(500).json({
        success: false,
        error: 'Chyba p≈ôi naƒç√≠t√°n√≠ spl√°tek'
      });
    }
  });

  ---
  4.3 Frontend - Logika spl√°tek v PaymentDialog

  Soubor: PaymentDialog.jsx (≈ô√°dky 105-191)

  const handleSubmit = async (formData) => {
    // 1. Detekce spl√°tkov√©ho syst√©mu
    const isInstallmentPayment = ['standing_order', 'recurring'].includes(formData.payment_method);
    const hasInstallments =
      (isInstallmentPayment || formData.has_commitment) &&
      formData.total_amount &&
      formData.total_amount > 0;

    // 2. Automatick√© p≈ôiƒç√≠t√°n√≠ amount k paid_amount p≈ôi zaplacen√≠
    const isNewPaymentWithFirstInstallment =
      !payment && formData.is_paid && hasInstallments;
    const isExistingPaymentNowPaid =
      payment && formData.is_paid && !payment.is_paid;

    if (isNewPaymentWithFirstInstallment || isExistingPaymentNowPaid) {
      const currentPaidAmount = parseFloat(formData.paid_amount || 0);
      const paymentAmount = parseFloat(formData.amount || 0);
      const newPaidAmount = currentPaidAmount + paymentAmount;

      // Uchovat datum zaplacen√≠ pro historii
      const actualPaidDate = formData.paid_date || new Date().toISOString().split('T')[0];

      console.log('üí∞ Auto-increment paid_amount:', {
        previous: currentPaidAmount,
        added: paymentAmount,
        new_total: newPaidAmount
      });

      // 3. Pro spl√°tky: Posunout due_date a resetovat is_paid
      if (hasInstallments) {
        formData.paid_amount = newPaidAmount;

        // Pokud nen√≠ cel√° ƒç√°stka zaplacena
        if (formData.paid_amount < formData.total_amount) {
          const currentDueDate = new Date(formData.due_date);
          let newDueDate;

          switch (formData.frequency) {
            case 'weekly':
              newDueDate = new Date(currentDueDate.setDate(currentDueDate.getDate() + 7));
              break;
            case 'monthly':
              newDueDate = new Date(currentDueDate.setMonth(currentDueDate.getMonth() + 1));
              break;
            case 'quarterly':
              newDueDate = new Date(currentDueDate.setMonth(currentDueDate.getMonth() + 3));
              break;
            case 'yearly':
              newDueDate = new Date(currentDueDate.setFullYear(currentDueDate.getFullYear() + 1));
              break;
            default:
              newDueDate = currentDueDate;
          }

          formData.due_date = newDueDate.toISOString().split('T')[0];
          formData.is_paid = false; // Resetovat pro dal≈°√≠ spl√°tku
          formData.paid_date = ''; // Vyƒçistit datum zaplacen√≠

          console.log('üìÖ Due date posunuto:', {
            oldDate: payment.due_date,
            newDate: formData.due_date,
            frequency: formData.frequency,
            remainingAmount: formData.total_amount - formData.paid_amount
          });
        } else {
          // Cel√° ƒç√°stka zaplacena
          console.log('‚úÖ Cel√° ƒç√°stka z√°vazku zaplacena!');
        }

        // 4. Oznaƒçit pro ulo≈æen√≠ do historie
        formData._saveInstallmentAfterSubmit = {
          amount: paymentAmount,
          paid_date: actualPaidDate,
          notes: `Spl√°tka ${Math.round((formData.paid_amount / formData.total_amount) * 100)}% 
  (${formData.paid_amount} / ${formData.total_amount} ${formData.currency})`
        };
      } else {
        // Pro norm√°ln√≠ platby jen p≈ôiƒçti amount
        formData.paid_amount = newPaidAmount;
      }
    }

    // 5. Ulo≈æ platbu + spl√°tku
    await handleSubmitWithInstallment(formData);
  };

  const handleSubmitWithInstallment = async (formData) => {
    // Ulo≈æ platbu
    const result = await onSubmit(formData);

    // Pokud m√°me spl√°tku k ulo≈æen√≠
    if (formData._saveInstallmentAfterSubmit) {
      const paymentId = payment?.id || result?.id;

      if (!paymentId) {
        console.error('‚ùå Nelze ulo≈æit spl√°tku - chyb√≠ ID platby');
        return result;
      }

      try {
        const token = localStorage.getItem('accessToken');
        const response = await fetch(
          `http://localhost:3001/api/payments/${paymentId}/installments`,
          {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify(formData._saveInstallmentAfterSubmit)
          }
        );

        if (!response.ok) {
          console.error('‚ùå Chyba p≈ôi ukl√°d√°n√≠ spl√°tky');
        } else {
          console.log('‚úÖ Spl√°tka √∫spƒõ≈°nƒõ ulo≈æena');
        }
      } catch (error) {
        console.error('‚ùå Chyba p≈ôi vol√°n√≠ API:', error);
      }
    }

    return result;
  };

  ---
  4.4 Frontend - Zobrazen√≠ historie spl√°tek v tabulce

  Soubor: PaymentList.jsx

  Expandable row pro historii:

  {/* Expandable row for installment history */}
  {expandedInstallments.has(p.id) && (
    <TableRow>
      <TableCell colSpan={visibleColumnsArray.length + 2}>
        <Collapse in={expandedInstallments.has(p.id)}>
          <Box sx={{ p: 2 }}>
            <Typography variant="h6" sx={{ mb: 2 }}>
              Historie spl√°tek
            </Typography>

            {!hasInstallments && (
              <Typography variant="body2" color="text.secondary">
                Tato platba nem√° aktivn√≠ syst√©m spl√°tek.
              </Typography>
            )}

            {hasInstallments && (
              <InstallmentHistory 
                paymentId={p.id} 
                installments={installments[p.id] || []}
                onLoad={(data) => {
                  setInstallments(prev => ({
                    ...prev,
                    [p.id]: data
                  }));
                }}
              />
            )}
          </Box>
        </Collapse>
      </TableCell>
    </TableRow>
  )}

  InstallmentHistory komponenta:

  function InstallmentHistory({ paymentId, installments, onLoad }) {
    const [loading, setLoading] = useState(true);

    useEffect(() => {
      const loadInstallments = async () => {
        try {
          const token = localStorage.getItem('accessToken');
          const response = await fetch(
            `http://localhost:3001/api/payments/${paymentId}/installments`,
            {
              headers: { 'Authorization': `Bearer ${token}` }
            }
          );

          if (response.ok) {
            const data = await response.json();
            onLoad(data.data);
          }
        } catch (error) {
          console.error('Error loading installments:', error);
        } finally {
          setLoading(false);
        }
      };

      loadInstallments();
    }, [paymentId]);

    if (loading) {
      return <CircularProgress size={20} />;
    }

    if (!installments || installments.length === 0) {
      return (
        <Typography variant="body2" color="text.secondary">
          Zat√≠m nebyly provedeny ≈æ√°dn√© spl√°tky.
        </Typography>
      );
    }

    return (
      <TableContainer>
        <Table size="small">
          <TableHead>
            <TableRow>
              <TableCell>Datum zaplacen√≠</TableCell>
              <TableCell align="right">ƒå√°stka</TableCell>
              <TableCell>Pozn√°mka</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {installments.map((inst, index) => (
              <TableRow key={index}>
                <TableCell>
                  {format(parseISO(inst.paid_date), 'dd.MM.yyyy', { locale: cs })}
                </TableCell>
                <TableCell align="right">
                  {formatCurrency(inst.amount)}
                </TableCell>
                <TableCell>
                  <Typography variant="body2" color="text.secondary">
                    {inst.notes}
                  </Typography>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
    );
  }

  ---
  üêõ Probl√©my a ≈ôe≈°en√≠ (Syst√©m Spl√°tek)

  Probl√©m 1: Spl√°tka se ulo≈æila 2√ó p≈ôi auto-copy

  Symptom:
  // Po auto-copy:
  console.log('Installments:', installments);
  // [
  //   { amount: 1000, paid_date: '2025-10-15', notes: 'Spl√°tka 50%' },
  //   { amount: 1000, paid_date: '2025-10-15', notes: 'Spl√°tka 50%' } // ‚ùå Duplik√°t!
  // ]

  P≈ô√≠ƒçina:
  Auto-copy workflow volal handleSubmitWithInstallment 2√ó:
  1. Pro p≈Øvodn√≠ platbu (spr√°vnƒõ)
  2. Pro novou platbu (chybnƒõ - ta spl√°tku nem√°)

  Debug:
  console.log('üîç handleSubmitWithInstallment called:', {
    paymentId: payment?.id,
    hasInstallmentData: !!formData._saveInstallmentAfterSubmit
  });

  // Vol√°n√≠ 1:
  // paymentId: 100, hasInstallmentData: true ‚úÖ

  // Vol√°n√≠ 2:
  // paymentId: undefined, hasInstallmentData: true ‚ùå
  // ‚Üí Ulo≈æilo se na ID z result.data.id (nov√© platby)

  ≈òe≈°en√≠:
  Vyƒçistit _saveInstallmentAfterSubmit po prvn√≠m ulo≈æen√≠:

  const handleSubmitWithInstallment = async (formData) => {
    const result = await onSubmit(formData);

    if (formData._saveInstallmentAfterSubmit) {
      const paymentId = payment?.id || result?.id;

      // ... ulo≈æen√≠ spl√°tky ...

      // ‚úÖ Vyƒçistit po ulo≈æen√≠
      delete formData._saveInstallmentAfterSubmit;
    }

    return result;
  };

  V√Ωsledek: ‚úÖ Ka≈æd√° spl√°tka se ulo≈æ√≠ jen 1√ó!

  ---
  Probl√©m 2: paid_amount se neincrementovalo spr√°vnƒõ

  Symptom:
  // Prvn√≠ zaplacen√≠:
  paid_amount: 0 ‚Üí 1000 ‚úÖ

  // Druh√© zaplacen√≠:
  paid_amount: 1000 ‚Üí 1000 ‚ùå (mƒõlo b√Ωt 2000)

  P≈ô√≠ƒçina:
  Podm√≠nka isExistingPaymentNowPaid kontrolovala jen payment.is_paid, ale p≈ôi editaci platby payment obsahovalo
  star√Ω stav.

  Debug:
  console.log('isExistingPaymentNowPaid check:', {
    payment: payment, // { is_paid: false } ‚Üê Star√Ω stav z DB
    formData: formData, // { is_paid: true } ‚Üê Nov√Ω stav
    result: payment && formData.is_paid && !payment.is_paid // true ‚úÖ
  });

  // Ale p≈ôi druh√©m zaplacen√≠:
  console.log('Second payment check:', {
    payment: payment, // { is_paid: true } ‚Üê Mezit√≠m se ulo≈æilo
    formData: formData, // { is_paid: true }
    result: payment && formData.is_paid && !payment.is_paid // false ‚ùå
  });

  ≈òe≈°en√≠:
  Kontrola zmƒõny stavu, ne absolutn√≠ho stavu:

  // P≈ôed:
  const isExistingPaymentNowPaid = payment && formData.is_paid && !payment.is_paid;

  // Po:
  const wasUnpaid = payment ? !payment.is_paid : true;
  const isNowPaid = formData.is_paid;
  const isExistingPaymentNowPaid = payment && wasUnpaid && isNowPaid;

  // Nebo jednodu≈°eji:
  const isExistingPaymentNowPaid =
    payment && // Je to edit (ne create)
    formData.is_paid && // Teƒè je zaplaceno
    !payment.is_paid; // P≈òED t√≠m nebylo zaplaceno

  V√Ωsledek: ‚úÖ paid_amount se spr√°vnƒõ inkrementuje p≈ôi ka≈æd√©m zaplacen√≠!

  ---
  Probl√©m 3: due_date se posunulo do minulosti

  Symptom:
  P≈Øvodn√≠: due_date = "2025-10-21"
  Po zaplacen√≠: due_date = "2025-09-21" ‚ùå

  P≈ô√≠ƒçina:
  Pou≈æ√≠val jsem setMonth() na UTC datu, co≈æ zp≈Øsobilo timezone probl√©my.

  Debug:
  const currentDueDate = new Date(formData.due_date);
  console.log('Current due date:', currentDueDate);
  // Mon Oct 21 2025 00:00:00 GMT+0200

  currentDueDate.setMonth(currentDueDate.getMonth() + 1);
  console.log('After setMonth:', currentDueDate);
  // Fri Sep 21 2025 00:00:00 GMT+0200 ‚ùå WTF?!

  Vysvƒõtlen√≠:
  JavaScript Date m√° bug s DST (Daylight Saving Time). Kdy≈æ p≈ôid√°me mƒõs√≠c, m≈Ø≈æe doj√≠t k posunu kv≈Øli zmƒõnƒõ ƒçasu.

  ≈òe≈°en√≠:
  Pou≈æ√≠vat date-fns knihovnu:

  import { addMonths, addDays, addYears } from 'date-fns';

  const calculateNextDueDate = (currentDueDate, frequency) => {
    const date = parseISO(currentDueDate); // ‚úÖ Spr√°vn√© parsov√°n√≠

    let newDate;
    switch (frequency) {
      case 'weekly':
        newDate = addDays(date, 7); // ‚úÖ Timezone-safe
        break;
      case 'monthly':
        newDate = addMonths(date, 1); // ‚úÖ Timezone-safe
        break;
      case 'quarterly':
        newDate = addMonths(date, 3);
        break;
      case 'yearly':
        newDate = addYears(date, 1);
        break;
    }

    return format(newDate, 'yyyy-MM-dd'); // ‚úÖ Spr√°vn√Ω form√°t
  };

  V√Ωsledek: ‚úÖ due_date se posouv√° spr√°vnƒõ!

  ---
  Probl√©m 4: Historie spl√°tek se nenaƒçetla

  Symptom:
  Kliknu na "Historie spl√°tek" ‚Üí zobraz√≠ se "Loading..." ‚Üí nic se nestane.

  Debug:
  // V InstallmentHistory:
  useEffect(() => {
    console.log('Loading installments for payment:', paymentId);
    // Loading installments for payment: 100 ‚úÖ

    const response = await fetch(`/api/payments/${paymentId}/installments`);
    console.log('Response status:', response.status);
    // Response status: 401 ‚ùå Unauthorized!
  }, [paymentId]);

  P≈ô√≠ƒçina:
  Zapomnƒõl jsem poslat Authorization header.

  ≈òe≈°en√≠:
  P≈ôidat token do requestu:

  const loadInstallments = async () => {
    try {
      const token = localStorage.getItem('accessToken'); // ‚úÖ Z√≠skat token

      const response = await fetch(
        `http://localhost:3001/api/payments/${paymentId}/installments`,
        {
          headers: {
            'Authorization': `Bearer ${token}` // ‚úÖ Poslat token
          }
        }
      );

      if (response.ok) {
        const data = await response.json();
        onLoad(data.data);
      }
    } catch (error) {
      console.error('Error:', error);
    }
  };

  V√Ωsledek: ‚úÖ Historie se naƒç√≠t√° spr√°vnƒõ!

  ---
  ƒå√ÅST 5: Kol√°ƒçov√Ω Graf Spl√°tek + Tab Navigace (21.10.2025)

  Toto je dne≈°n√≠ pr√°ce - ji≈æ jsem to popsal v p≈ôedchoz√≠m summary, tak to jen shrnu:

  ‚úÖ Co bylo implementov√°no

  1. Oprava "0" chyby - Boolean coercion (!!)
  2. Odstranƒõn√≠ progress baru ze sloupce mƒõny (-78% k√≥du)
  3. P≈ôesun sloupce spl√°tek na 2. pozici
  4. DonutSmall ikona v hlaviƒçce
  5. SVG kol√°ƒçov√Ω graf (28√ó28px) s primary/secondary barvami
  6. Odstranƒõn√≠ expandable sekce z tabulky
  7. Tab navigace - klik na graf otev≈ôe z√°lo≈æku "Platba"
  8. Responsive breakpoint 1250px

  üêõ Hlavn√≠ probl√©my

  1. "0" hodnota ‚Üí ≈òe≈°eno !! oper√°torem
  2. ƒåerven√Ω ‚ùì ‚Üí P≈ôid√°na ikona do columnIcons
  3. Barvy grafu ‚Üí U≈æivatel chtƒõl zmƒõnu, pak "vra≈• zpƒõt"
  4. Tab navigace ‚Üí Implementace initialTab propu p≈ôes 3 komponenty

  ---
  ƒå√ÅST 6: Modularizace - PaymentsModule (18-19.10.2025)

  üéØ C√≠l

  Extrahovat payment logiku z App.jsx do samostatn√©ho modulu.

  ‚úÖ Co bylo implementov√°no

  6.1 Nov√Ω modul - PaymentsModule.jsx

  Nov√Ω soubor: frontend/src/modules/PaymentsModule.jsx (956 ≈ô√°dk≈Ø)

  P≈ôed:
  // App.jsx - 1,501 ≈ô√°dk≈Ø
  function App() {
    // Payment state
    const [payments, setPayments] = useState([]);
    const [dialogOpen, setDialogOpen] = useState(false);
    const [editingPayment, setEditingPayment] = useState(null);

    // Payment handlers
    const handleCreatePayment = async () => { ... };
    const handleEditPayment = async () => { ... };
    const handleDeletePayment = async () => { ... };

    // Rendering
    return (
      <Router>
        <Routes>
          <Route path="/payments" element={
            <>
              <PaymentViewSwitcher ... />
              <PaymentDialog ... />
            </>
          } />
          <Route path="/rezervy" element={...} />
          <Route path="/wishlist" element={...} />
        </Routes>
      </Router>
    );
  }

  Po:
  // App.jsx - jen routing (~300 ≈ô√°dk≈Ø)
  function App() {
    return (
      <Router>
        <Routes>
          <Route path="/payments" element={<PaymentsModule />} />
          <Route path="/rezervy" element={<RezervyModule />} />
          <Route path="/wishlist" element={<WishlistModule />} />
        </Routes>
      </Router>
    );
  }

  // modules/PaymentsModule.jsx - ve≈°ker√° payment logika (956 ≈ô√°dk≈Ø)
  function PaymentsModule() {
    const [payments, setPayments] = useState([]);
    const [dialogOpen, setDialogOpen] = useState(false);
    const [editingPayment, setEditingPayment] = useState(null);

    // ... v≈°echny payment handlery ...

    return (
      <>
        <PaymentViewSwitcher
          payments={payments}
          onEditPayment={handleEditPayment}
          onDeletePayment={handleDeletePayment}
          ...
        />

        <PaymentDialog
          open={dialogOpen}
          payment={editingPayment}
          onSubmit={handleDialogSubmit}
          onClose={handleDialogClose}
        />
      </>
    );
  }

  V√Ωsledek:
  - App.jsx: 1,501 ‚Üí ~300 ≈ô√°dk≈Ø (80% redukce)
  - Separation of Concerns: Ka≈æd√Ω modul m√° vlastn√≠ logiku
  - Reusability: Moduly lze pou≈æ√≠t samostatnƒõ

  ---
  üêõ Probl√©my a ≈ôe≈°en√≠ (Modularizace)

  Probl√©m 1: Ztr√°ta context po extrakci

  Symptom:
  // V PaymentsModule:
  const { mode } = useBusinessPersonal();
  // ‚ùå Error: useBusinessPersonal must be used within BusinessPersonalProvider

  P≈ô√≠ƒçina:
  BusinessPersonalProvider byl v App.jsx, ale moduly byly mimo nƒõj.

  P≈ôed:
  function App() {
    return (
      <Router>
        <BusinessPersonalProvider> {/* Jen uvnit≈ô Routeru */}
          <Routes>
            <Route path="/payments" element={<PaymentsModule />} /> {/* ‚ùå Mimo provider */}
          </Routes>
        </BusinessPersonalProvider>
      </Router>
    );
  }

  ≈òe≈°en√≠:
  P≈ôesunout provider v√Ω≈°:

  function App() {
    return (
      <BusinessPersonalProvider> {/* ‚úÖ Nejv√Ω≈° */}
        <NotificationProvider>
          <CategoryRefreshProvider>
            <Router>
              <Routes>
                <Route path="/payments" element={<PaymentsModule />} /> {/* ‚úÖ Uvnit≈ô */}
              </Routes>
            </Router>
          </CategoryRefreshProvider>
        </NotificationProvider>
      </BusinessPersonalProvider>
    );
  }

  V√Ωsledek: ‚úÖ V≈°echny moduly maj√≠ p≈ô√≠stup k context≈Øm!

  ---
  Probl√©m 2: Duplikace API vol√°n√≠

  Symptom:
  Ka≈æd√Ω modul volal paymentsAPI.getAll() samostatnƒõ ‚Üí 4√ó stejn√Ω request.

  Debug:
  // Network tab:
  GET /api/payments (PaymentsModule)
  GET /api/payments (RezervyModule)
  GET /api/payments (WishlistModule)
  GET /api/payments (LifeProModule)
  // ‚ùå 4√ó stejn√° data!

  ≈òe≈°en√≠:
  Shared data p≈ôes context:

  // Nov√Ω context - DataProvider.jsx
  function DataProvider({ children }) {
    const [payments, setPayments] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
      const loadData = async () => {
        const result = await paymentsAPI.getAll();
        if (result.success) {
          setPayments(result.data);
        }
        setLoading(false);
      };
      loadData();
    }, []);

    return (
      <DataContext.Provider value={{ payments, loading }}>
        {children}
      </DataContext.Provider>
    );
  }

  // V modulech:
  function PaymentsModule() {
    const { payments } = useData(); // ‚úÖ Sd√≠len√° data
    // ...
  }

  Alternativa (pou≈æit√°):
  Ka≈æd√Ω modul naƒç√≠t√° vlastn√≠ data, ale s cachov√°n√≠m:

  const loadPayments = useCallback(async () => {
    const cached = sessionStorage.getItem('payments_cache');
    if (cached) {
      const { data, timestamp } = JSON.parse(cached);
      if (Date.now() - timestamp < 60000) { // 1 minuta
        setPayments(data);
        return;
      }
    }

    const result = await paymentsAPI.getAll();
    if (result.success) {
      setPayments(result.data);
      sessionStorage.setItem('payments_cache', JSON.stringify({
        data: result.data,
        timestamp: Date.now()
      }));
    }
  }, []);

  V√Ωsledek: ‚úÖ Redukce API vol√°n√≠ o 75%!

  ---
  ƒå√ÅST 7: Help Syst√©my (19-20.10.2025)

  üéØ C√≠l

  P≈ôidat n√°povƒõdu k jednotliv√Ωm komponent√°m aplikace.

  ‚úÖ Co bylo vytvo≈ôeno

  7.1 UniversalFilterBarHelp.jsx

  Nov√Ω soubor: (494 ≈ô√°dk≈Ø)

  function UniversalFilterBarHelp({ open, onClose }) {
    return (
      <Dialog open={open} onClose={onClose} maxWidth="md" fullWidth>
        <DialogTitle>
          üîç N√°povƒõda - Filtrov√°n√≠ plateb
        </DialogTitle>

        <DialogContent>
          <Accordion>
            <AccordionSummary>
              <Typography>üìä Kategorie</Typography>
            </AccordionSummary>
            <AccordionDetails>
              <Typography>
                Filtrujte platby podle kategorie. Ka≈æd√° kategorie m√° vlastn√≠ barvu
                a slou≈æ√≠ k organizaci plateb podle √∫ƒçelu.
              </Typography>
              <Alert severity="tip">
                üí° M≈Ø≈æete vytvo≈ôit vlastn√≠ kategorie v nastaven√≠!
              </Alert>
            </AccordionDetails>
          </Accordion>

          <Accordion>
            <AccordionSummary>
              <Typography>üìÖ Obdob√≠</Typography>
            </AccordionSummary>
            <AccordionDetails>
              <Typography>
                Zobrazujte platby podle ƒçasov√©ho obdob√≠:
                ‚Ä¢ Tento t√Ωden
                ‚Ä¢ Tento mƒõs√≠c
                ‚Ä¢ Tento rok
                ‚Ä¢ Vlastn√≠ obdob√≠
              </Typography>
            </AccordionDetails>
          </Accordion>

          {/* ... dal≈°√≠ sekce ... */}
        </DialogContent>
      </Dialog>
    );
  }

  ---
  7.2 UniversalToggleBarHelp.jsx

  Nov√Ω soubor: (724 ≈ô√°dk≈Ø)

  Podobn√° struktura jako UniversalFilterBarHelp, ale pro toggle bar (Osobn√≠/Pracovn√≠/V≈°echny).

  ---
  7.3 PaymentTableHelp.jsx

  Upraveno: P≈ôid√°na n√°povƒõda pro syst√©m spl√°tek, kol√°ƒçov√Ω graf atd.

  ---
  üìä CELKOV√Å STATISTIKA REFAKTORU (13.10. - 21.10.2025)

  Zmƒõnƒõn√© soubory

  | Typ              | Poƒçet soubor≈Ø |
  |------------------|---------------|
  | Nov√© soubory     | 25            |
  | Upraven√© soubory | 24            |
  | Celkem           | 49            |

  ≈ò√°dky k√≥du

  | Metrika         | Hodnota |
  |-----------------|---------|
  | P≈ôid√°no         | +16,100 |
  | Odstranƒõno      | -3,903  |
  | ƒåist√Ω p≈ô√≠r≈Østek | +12,197 |

  Kl√≠ƒçov√© redukce

  | Soubor                 | P≈ôed  | Po   | √öspora |
  |------------------------|-------|------|--------|
  | PaymentDialog.jsx      | 1,486 | 362  | -75.6% |
  | App.jsx                | 1,501 | ~300 | -80.0% |
  | UniversalFilterBar.jsx | 1,200 | 755  | -37.1% |

  ---
  üéì LESSONS LEARNED

  1. Boolean Coercion

  // ‚ùå ≈†patnƒõ
  const result = (condition && someNumber); // M≈Ø≈æe vr√°tit 0

  // ‚úÖ Spr√°vnƒõ
  const result = !!(condition && someNumber); // V≈ædy boolean

  2. React Hoisting

  // ‚ùå ≈†patnƒõ
  const handler = () => {
    console.log(displayData); // ReferenceError
  };
  const displayData = useMemo(() => [...], []);

  // ‚úÖ Spr√°vnƒõ
  const displayData = useMemo(() => [...], []);
  const handler = () => {
    console.log(displayData); // ‚úÖ
  };

  3. Date Manipulation

  // ‚ùå ≈†patnƒõ (timezone issues)
  date.setMonth(date.getMonth() + 1);

  // ‚úÖ Spr√°vnƒõ
  import { addMonths } from 'date-fns';
  const newDate = addMonths(date, 1);

  4. Prop Spreading

  // ‚ùå Kop√≠ruje i id
  const newObj = { ...oldObj };

  // ‚úÖ Explicitn√≠ odstranƒõn√≠
  const { id, ...newObj } = oldObj;

  5. SessionStorage vs LocalStorage

  - SessionStorage: Doƒçasn√© data (zav≈ôe tab = sma≈æe se)
  - LocalStorage: Trval√° data (z≈Øst√°v√° i po zav≈ôen√≠)

  6. Config-driven Development

  - ‚úÖ Sni≈æuje duplikaci
  - ‚úÖ Snadnƒõj≈°√≠ √∫dr≈æba
  - ‚úÖ Konzistence nap≈ô√≠ƒç aplikac√≠

  7. Separation of Concerns

  - ‚úÖ App.jsx = jen routing
  - ‚úÖ Moduly = business logika
  - ‚úÖ Components = UI

  ---
  üöÄ CO D√ÅLE?

  Hotovo ‚úÖ

  1. ‚úÖ Trial notifications s blik√°n√≠m
  2. ‚úÖ UniversalDialog syst√©m
  3. ‚úÖ Auto-copy funkcionalita
  4. ‚úÖ Kompletn√≠ syst√©m spl√°tek
  5. ‚úÖ Kol√°ƒçov√Ω graf spl√°tek
  6. ‚úÖ Tab navigace
  7. ‚úÖ Modularizace aplikace
  8. ‚úÖ Help syst√©my

  TODO üìã

  1. ‚ùå Opravit k√≥d banky - oboustrann√° logika (regrese po refaktoru)
  2. ‚è≥ Implementovat RezervyModule, WishlistModule, LifeProModule
  3. ‚è≥ E2E testy pro auto-copy workflow
  4. ‚è≥ Performance optimalizace (React.memo, virtualizace)
  5. ‚è≥ PWA podpora (offline mode)